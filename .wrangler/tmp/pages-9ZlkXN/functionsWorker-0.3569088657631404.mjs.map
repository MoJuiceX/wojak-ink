{
  "version": 3,
  "sources": ["../bundle-t1QkpV/checked-fetch.js", "../../../functions/api/offers.js", "../../../functions/api/tangify.js", "../../../functions/api/wallet-balances.js", "functionsRoutes-0.611172221830512.mjs", "../../../../node_modules/path-to-regexp/src/index.ts", "../../../../node_modules/wrangler/templates/pages-template-worker.ts", "../../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-t1QkpV/middleware-insertion-facade.js", "../../../../node_modules/wrangler/templates/middleware/common.ts", "../bundle-t1QkpV/middleware-loader.entry.ts"],
  "sourceRoot": "/Users/abit_hex/Downloads/wojak-ink-v2/wojak-ink/.wrangler/tmp/pages-9ZlkXN/functionsWorker-0.3569088657631404.mjs",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t\t);\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", "/**\n * Cloudflare Pages Function: Live Offers Proxy\n * \n * Proxies MintGarden API to fetch live offers with server-side caching.\n * Implements \"very slow\" API usage policy: 1-hour cache, manual refresh with 60s cooldown.\n * \n * Endpoint: /api/offers?force=1&ts=timestamp\n * \n * Cache Strategy:\n * - Normal requests: offers:normal (TTL 3600s)\n * - Forced requests: offers:forced (TTL 60s)\n * - One-flight lock prevents parallel upstream fetches\n */\n\nconst SERVER_CACHE_TTL_S = 3600  // 1 hour\nconst MANUAL_REFRESH_COOLDOWN_S = 60  // 1 minute minimum between forced refreshes\n\n// Configuration (from env or constants)\nconst COLLECTION_ID = 'col10hfq4hml2z0z0wutu3a9hvt60qy9fcq4k4dznsfncey4lu6kpt3su7u9ah'\nconst TOKEN_ID = 'xch'\nconst API_BASE = `https://api.mintgarden.io/collections/${COLLECTION_ID}/nfts/by_offers`\n\n// One-flight lock (best-effort, resets on cold start)\nlet fetchPromise = null\n\n// Fetch with retry logic\nasync function fetchWithRetry(url, maxRetries = 5) {\n  let lastError\n  for (let attempt = 0; attempt < maxRetries; attempt++) {\n    try {\n      const response = await fetch(url)\n      \n      if (response.status === 429 || response.status === 503 || response.status === 504) {\n        if (attempt < maxRetries - 1) {\n          const backoff = Math.min(1000 * Math.pow(2, attempt), 5000)\n          await new Promise(resolve => setTimeout(resolve, backoff))\n          continue\n        }\n      }\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`)\n      }\n      \n      return await response.json()\n    } catch (err) {\n      lastError = err\n      if (attempt < maxRetries - 1) {\n        const backoff = Math.min(1000 * Math.pow(2, attempt), 5000)\n        await new Promise(resolve => setTimeout(resolve, backoff))\n      }\n    }\n  }\n  throw lastError || new Error('Failed to fetch after retries')\n}\n\n// Extract launcher_bech32 from MintGarden item\nfunction extractLauncher(item) {\n  if (item.encoded_id && typeof item.encoded_id === 'string' && item.encoded_id.startsWith('nft1')) {\n    return item.encoded_id\n  }\n  if (item.encodedId && typeof item.encodedId === 'string' && item.encodedId.startsWith('nft1')) {\n    return item.encodedId\n  }\n  if (item.launcher_bech32 && typeof item.launcher_bech32 === 'string' && item.launcher_bech32.startsWith('nft1')) {\n    return item.launcher_bech32\n  }\n  if (item.launcherBech32 && typeof item.launcherBech32 === 'string' && item.launcherBech32.startsWith('nft1')) {\n    return item.launcherBech32\n  }\n  if (item.id && typeof item.id === 'string' && item.id.startsWith('nft1')) {\n    return item.id\n  }\n  return null\n}\n\n// Extract raw price from item\nfunction extractRawPrice(item) {\n  if (item.xch_price !== undefined && item.xch_price !== null) {\n    return item.xch_price\n  }\n  if (item.price?.xch_price !== undefined && item.price.xch_price !== null) {\n    return item.price.xch_price\n  }\n  if (item.price !== undefined && item.price !== null) {\n    return item.price\n  }\n  if (item.amount !== undefined && item.amount !== null) {\n    return item.amount\n  }\n  if (item.listing_price !== undefined && item.listing_price !== null) {\n    return item.listing_price\n  }\n  return null\n}\n\n// Normalize price_xch (deterministic)\nfunction normalizePrice(raw) {\n  if (raw === null || raw === undefined || isNaN(raw)) return null\n  \n  const rawNum = typeof raw === 'number' ? raw : parseFloat(raw)\n  if (isNaN(rawNum)) return null\n  \n  // If integer AND >= 1e9, treat as mojos\n  if (Number.isInteger(rawNum) && rawNum >= 1e9) {\n    return rawNum / 1e12\n  }\n  \n  // Otherwise treat as XCH\n  return rawNum\n}\n\n// Compute percentiles from sorted array\nfunction computePercentiles(sortedPrices, percentiles) {\n  if (sortedPrices.length === 0) return {}\n  const result = {}\n  for (const p of percentiles) {\n    const index = Math.floor((p / 100) * (sortedPrices.length - 1))\n    result[`p${p}`] = sortedPrices[index]\n  }\n  return result\n}\n\n// Fetch all offers from MintGarden (paginated)\nasync function fetchAllOffers(reverseMap) {\n  const listingsById = {}\n  let pageCursor = null\n  let totalItemsFetched = 0\n  \n  while (true) {\n    let url = `${API_BASE}?token_id=${TOKEN_ID}&size=100`\n    if (pageCursor) {\n      url += `&page=${encodeURIComponent(pageCursor)}`\n    }\n    \n    const response = await fetchWithRetry(url)\n    const items = response.items || []\n    const next = response.next\n    \n    if (items.length === 0) {\n      break\n    }\n    \n    totalItemsFetched += items.length\n    \n    for (const item of items) {\n      const launcher = extractLauncher(item)\n      if (!launcher) continue\n      \n      const rawPrice = extractRawPrice(item)\n      if (rawPrice === null) continue\n      \n      const priceXch = normalizePrice(rawPrice)\n      if (priceXch === null || priceXch <= 0) continue\n      \n      // Map launcher to internal ID\n      const internalId = reverseMap[launcher]\n      if (!internalId) continue\n      \n      // Create listing object\n      const nowIso = new Date().toISOString()\n      const listing = {\n        price_xch: priceXch,\n        timestamp: item.updated_at || item.data?.updated_at || nowIso,\n        updated_at: item.updated_at || item.data?.updated_at || nowIso\n      }\n      \n      // Add to listings for this ID\n      if (!listingsById[internalId]) {\n        listingsById[internalId] = {\n          best_listing: null\n        }\n      }\n      \n      // Update best_listing (lowest price)\n      if (!listingsById[internalId].best_listing || \n          listing.price_xch < listingsById[internalId].best_listing.price_xch) {\n        listingsById[internalId].best_listing = listing\n      }\n    }\n    \n    if (!next) {\n      break\n    }\n    \n    pageCursor = next\n    await new Promise(resolve => setTimeout(resolve, 100))\n  }\n  \n  return { listingsById, totalItemsFetched }\n}\n\n// Normalize response to match mintgarden_offers_index_v1.json schema\nfunction normalizeResponse(listingsById, collectionId) {\n  // Compute floor\n  let floorXch = null\n  let floorId = null\n  \n  for (const [id, data] of Object.entries(listingsById)) {\n    if (data.best_listing && data.best_listing.price_xch) {\n      if (floorXch === null || data.best_listing.price_xch < floorXch) {\n        floorXch = data.best_listing.price_xch\n        floorId = id\n      }\n    }\n  }\n  \n  // Compute market_stats\n  const prices = []\n  for (const [id, data] of Object.entries(listingsById)) {\n    if (data.best_listing && data.best_listing.price_xch) {\n      prices.push(data.best_listing.price_xch)\n    }\n  }\n  \n  let marketStats = {\n    floor_xch: floorXch,\n    listed_count: prices.length,\n    median_xch: null,\n    p10_xch: null,\n    p90_xch: null\n  }\n  \n  if (prices.length > 0) {\n    const sortedPrices = [...prices].sort((a, b) => a - b)\n    const percentiles = computePercentiles(sortedPrices, [10, 50, 90])\n    marketStats.median_xch = percentiles.p50 || null\n    marketStats.p10_xch = percentiles.p10 || null\n    marketStats.p90_xch = percentiles.p90 || null\n  }\n  \n  return {\n    schema_version: \"1.0\",\n    generated_at: new Date().toISOString(),\n    collection_id: collectionId,\n    floor_xch: floorXch,\n    floor_id: floorId,\n    count: Object.keys(listingsById).length,\n    market_stats: marketStats,\n    listings_by_id: listingsById\n  }\n}\n\n// Load launcher map reverse lookup (from public asset)\nasync function loadReverseMap(request) {\n  try {\n    // Construct URL to launcher map asset\n    const url = new URL(request.url)\n    const origin = url.origin\n    const launcherMapUrl = `${origin}/assets/BigPulp/mintgarden_launcher_map_runtime_v1.json`\n    \n    const response = await fetch(launcherMapUrl)\n    if (!response.ok) {\n      // Fallback to legacy filename\n      const legacyUrl = `${origin}/assets/BigPulp/mintgarden_launcher_map_v1.json`\n      const legacyResponse = await fetch(legacyUrl)\n      if (!legacyResponse.ok) {\n        throw new Error(`Failed to fetch launcher map: ${legacyResponse.status}`)\n      }\n      const data = await legacyResponse.json()\n      if (!data.map) {\n        throw new Error('Launcher map has no map field')\n      }\n      // Build reverse map\n      const reverseMap = {}\n      for (const [id, launcher] of Object.entries(data.map)) {\n        reverseMap[launcher] = id\n      }\n      return reverseMap\n    }\n    \n    const data = await response.json()\n    if (!data.map) {\n      throw new Error('Launcher map has no map field')\n    }\n    \n    // Build reverse map from map (id -> launcher)\n    const reverseMap = {}\n    for (const [id, launcher] of Object.entries(data.map)) {\n      reverseMap[launcher] = id\n    }\n    \n    return reverseMap\n  } catch (err) {\n    console.error('[Offers API] Could not load launcher map:', err.message)\n    throw err\n  }\n}\n\nexport async function onRequestGet(context) {\n  const { request, env } = context\n  const url = new URL(request.url)\n  const force = url.searchParams.get('force') === '1'\n  \n  // Build clean cache key URL (no query params)\n  const cacheKeyUrl = new URL(request.url)\n  cacheKeyUrl.search = ''  // Remove all query params\n  cacheKeyUrl.pathname = force ? '/__cache/offers/forced' : '/__cache/offers/normal'\n  const cacheRequest = new Request(cacheKeyUrl.toString(), { method: 'GET' })\n  \n  // Check cache first\n  const cached = await caches.default.match(cacheRequest)\n  if (cached) {\n    console.log(`[Offers API] Cache hit (${force ? 'forced' : 'normal'})`)\n    // Clone response to add cache status headers\n    const headers = new Headers(cached.headers)\n    headers.set('X-Offers-Cache', 'HIT')\n    headers.set('X-Offers-Key', force ? 'forced' : 'normal')\n    return new Response(cached.body, {\n      status: cached.status,\n      statusText: cached.statusText,\n      headers: headers\n    })\n  }\n  \n  // One-flight lock: if fetch in progress, await it\n  if (fetchPromise) {\n    console.log('[Offers API] One-flight lock: awaiting existing fetch')\n    try {\n      const { payloadText, generatedAt } = await fetchPromise\n      \n      // CRITICAL: If this is a forced request during a normal fetchPromise,\n      // we must seed the forced cache key to maintain cooldown protection\n      if (force) {\n        const forcedKeyUrl = new URL(request.url)\n        forcedKeyUrl.search = ''\n        forcedKeyUrl.pathname = '/__cache/offers/forced'\n        const forcedCacheRequest = new Request(forcedKeyUrl.toString(), { method: 'GET' })\n        \n        const responseForced = new Response(payloadText, {\n          status: 200,\n          headers: {\n            'Content-Type': 'application/json',\n            'Access-Control-Allow-Origin': '*',\n            'Cache-Control': `public, max-age=0, s-maxage=${MANUAL_REFRESH_COOLDOWN_S}`,\n            'X-Offers-Generated-At': generatedAt,\n            'X-Cache-Mode': 'forced',\n            'X-Offers-Cache': 'MISS',\n            'X-Offers-Key': 'forced'\n          }\n        })\n        \n        // Seed forced cache so cooldown protection works under concurrency\n        context.waitUntil(caches.default.put(forcedCacheRequest, responseForced.clone()))\n        \n        return responseForced\n      } else {\n        // Normal request: return normal response\n        return new Response(payloadText, {\n          status: 200,\n          headers: {\n            'Content-Type': 'application/json',\n            'Access-Control-Allow-Origin': '*',\n            'Cache-Control': `public, max-age=0, s-maxage=${SERVER_CACHE_TTL_S}`,\n            'X-Offers-Generated-At': generatedAt,\n            'X-Cache-Mode': 'normal',\n            'X-Offers-Cache': 'MISS',\n            'X-Offers-Key': 'normal'\n          }\n        })\n      }\n    } catch (err) {\n      // If existing fetch failed, continue to new fetch\n      fetchPromise = null\n    }\n  }\n  \n  // Start new fetch\n  const startTime = Date.now()\n  fetchPromise = (async () => {\n    try {\n      console.log(`[Offers API] Cache miss, fetching from MintGarden (forced: ${force})`)\n      \n      // Load reverse map from public asset\n      const reverseMap = await loadReverseMap(request)\n      \n      // Fetch all offers\n      const { listingsById, totalItemsFetched } = await fetchAllOffers(reverseMap)\n      \n      // Normalize response\n      const collectionId = env?.COLLECTION_ID || COLLECTION_ID\n      const normalized = normalizeResponse(listingsById, collectionId)\n      \n      const duration = Date.now() - startTime\n      console.log(`[Offers API] Fetched ${totalItemsFetched} items, ${normalized.count} listings, duration: ${duration}ms`)\n      \n      const payloadText = JSON.stringify(normalized)\n      const generatedAt = normalized.generated_at\n      \n      // Create responses with different TTLs (s-maxage for edge, max-age=0 for browser)\n      const responseForced = new Response(payloadText, {\n        status: 200,\n        headers: {\n          'Content-Type': 'application/json',\n          'Access-Control-Allow-Origin': '*',\n          'Cache-Control': `public, max-age=0, s-maxage=${MANUAL_REFRESH_COOLDOWN_S}`,\n          'X-Offers-Generated-At': generatedAt,\n          'X-Cache-Mode': 'forced',\n          'X-Offers-Cache': 'MISS',\n          'X-Offers-Key': 'forced'\n        }\n      })\n      \n      const responseNormal = new Response(payloadText, {\n        status: 200,\n        headers: {\n          'Content-Type': 'application/json',\n          'Access-Control-Allow-Origin': '*',\n          'Cache-Control': `public, max-age=0, s-maxage=${SERVER_CACHE_TTL_S}`,\n          'X-Offers-Generated-At': generatedAt,\n          'X-Cache-Mode': 'normal',\n          'X-Offers-Cache': 'MISS',\n          'X-Offers-Key': 'normal'\n        }\n      })\n      \n      // Cache both if forced, only normal if not forced\n      // After force=1, next normal request should return same X-Offers-Generated-At as forced.\n      if (force) {\n        const forcedKeyUrl = new URL(request.url)\n        forcedKeyUrl.search = ''\n        forcedKeyUrl.pathname = '/__cache/offers/forced'\n        const forcedCacheRequest = new Request(forcedKeyUrl.toString(), { method: 'GET' })\n        \n        const normalKeyUrl = new URL(request.url)\n        normalKeyUrl.search = ''\n        normalKeyUrl.pathname = '/__cache/offers/normal'\n        const normalCacheRequest = new Request(normalKeyUrl.toString(), { method: 'GET' })\n        \n        await Promise.all([\n          caches.default.put(forcedCacheRequest, responseForced.clone()),\n          caches.default.put(normalCacheRequest, responseNormal.clone())\n        ])\n      } else {\n        const normalKeyUrl = new URL(request.url)\n        normalKeyUrl.search = ''\n        normalKeyUrl.pathname = '/__cache/offers/normal'\n        const normalCacheRequest = new Request(normalKeyUrl.toString(), { method: 'GET' })\n        \n        await caches.default.put(normalCacheRequest, responseNormal.clone())\n      }\n      \n      return { payloadText, generatedAt }  // Return object, not Response\n    } catch (err) {\n      console.error('[Offers API] Error:', err)\n      fetchPromise = null\n      throw err\n    } finally {\n      fetchPromise = null\n    }\n  })()\n  \n  try {\n    const { payloadText, generatedAt } = await fetchPromise\n    \n    // Create response with correct TTL based on force flag\n    if (force) {\n      return new Response(payloadText, {\n        status: 200,\n        headers: {\n          'Content-Type': 'application/json',\n          'Access-Control-Allow-Origin': '*',\n          'Cache-Control': `public, max-age=0, s-maxage=${MANUAL_REFRESH_COOLDOWN_S}`,\n          'X-Offers-Generated-At': generatedAt,\n          'X-Cache-Mode': 'forced',\n          'X-Offers-Cache': 'MISS',\n          'X-Offers-Key': 'forced'\n        }\n      })\n    } else {\n      return new Response(payloadText, {\n        status: 200,\n        headers: {\n          'Content-Type': 'application/json',\n          'Access-Control-Allow-Origin': '*',\n          'Cache-Control': `public, max-age=0, s-maxage=${SERVER_CACHE_TTL_S}`,\n          'X-Offers-Generated-At': generatedAt,\n          'X-Cache-Mode': 'normal',\n          'X-Offers-Cache': 'MISS',\n          'X-Offers-Key': 'normal'\n        }\n      })\n    }\n  } catch (err) {\n    return new Response(\n      JSON.stringify({ \n        error: 'Failed to fetch offers',\n        message: err.message \n      }),\n      {\n        status: 500,\n        headers: {\n          'Content-Type': 'application/json',\n          'Access-Control-Allow-Origin': '*'\n        }\n      }\n    )\n  }\n}\n\n", "const corsHeaders = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Methods': 'POST, OPTIONS',\n  'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n  'Access-Control-Expose-Headers': 'X-Tangify-Model',\n}\n\nconst MAX_IMAGE_BYTES = 6 * 1024 * 1024 // 6MB\n\nfunction base64ToBytes(b64) {\n  if (typeof atob === 'function') {\n    const bin = atob(b64)\n    const bytes = new Uint8Array(bin.length)\n    for (let i = 0; i < bin.length; i++) {\n      bytes[i] = bin.charCodeAt(i)\n    }\n    return bytes\n  }\n  // fallback if needed (for Node.js environments)\n  const buf = Buffer.from(b64, 'base64')\n  return new Uint8Array(buf)\n}\n\nasync function callEdits({ model, apiKey, imageFile, prompt }) {\n  const fd = new FormData()\n  fd.append('model', model)\n  fd.append('image', imageFile, imageFile.name || 'input.png')\n  fd.append('prompt', prompt)\n  fd.append('size', '1024x1024')\n\n  if (model === 'gpt-image-1') {\n    fd.append('input_fidelity', 'high')\n    // DO NOT add response_format (not supported)\n  }\n\n  if (model === 'dall-e-2') {\n    fd.append('response_format', 'b64_json')\n  }\n\n  try {\n    // Add timeout using AbortController (Cloudflare Workers support this)\n    const controller = new AbortController()\n    const timeoutId = setTimeout(() => controller.abort(), 120000) // 120 second timeout\n\n    const response = await fetch('https://api.openai.com/v1/images/edits', {\n      method: 'POST',\n      headers: { Authorization: `Bearer ${apiKey}` },\n      body: fd,\n      signal: controller.signal,\n    })\n\n    clearTimeout(timeoutId)\n\n    let json = null\n    try {\n      json = await response.json()\n    } catch (e) {\n      console.warn('OpenAI response was not JSON:', e)\n      // Try to get text response for debugging\n      try {\n        const text = await response.text()\n        console.warn('OpenAI response text:', text.substring(0, 500))\n      } catch (e2) {\n        console.warn('Could not read response as text either')\n      }\n    }\n\n    return { ok: response.ok, status: response.status, json }\n  } catch (error) {\n    // Handle network errors, timeouts, etc.\n    if (error.name === 'AbortError') {\n      console.error('OpenAI API request timed out after 120 seconds')\n      return { \n        ok: false, \n        status: 504, \n        json: { error: { message: 'Request timed out. The image generation is taking too long.' } } \n      }\n    }\n    console.error('OpenAI API request failed:', error)\n    return { \n      ok: false, \n      status: 500, \n      json: { error: { message: `Network error: ${error.message || 'Connection failed'}` } } \n    }\n  }\n}\n\nfunction isVerificationOrPermissionError(json, status) {\n  if (!(status === 401 || status === 403)) return false\n\n  const msg = (json?.error?.message || '').toLowerCase()\n\n  return (\n    msg.includes('must be verified') ||\n    msg.includes('organization must be verified') ||\n    msg.includes('verify organization') ||\n    msg.includes('not authorized') ||\n    msg.includes('permission') ||\n    msg.includes('insufficient') ||\n    msg.includes('identity')\n  )\n}\n\nexport async function onRequestPost(context) {\n  const { request, env } = context\n\n  if (request.method === 'OPTIONS') {\n    return new Response(null, { \n      status: 204,\n      headers: corsHeaders \n    })\n  }\n\n  try {\n    const apiKey = env.OPENAI_API_KEY\n\n    if (!apiKey) {\n      return new Response(\n        JSON.stringify({ error: 'OpenAI API key not configured' }),\n        { \n          status: 500, \n          headers: { ...corsHeaders, 'Content-Type': 'application/json' } \n        }\n      )\n    }\n\n    // Parse multipart form-data\n    let form\n    try {\n      form = await request.formData()\n    } catch (parseError) {\n      console.error('Failed to parse form data:', parseError)\n      return new Response(\n        JSON.stringify({ error: 'Invalid request. Expected multipart/form-data.' }),\n        { \n          status: 400, \n          headers: { ...corsHeaders, 'Content-Type': 'application/json' } \n        }\n      )\n    }\n\n    // Extract and validate image\n    const imageFile = form.get('image')\n    \n    if (!imageFile || !(imageFile instanceof File)) {\n      return new Response(\n        JSON.stringify({ error: 'No image file provided. Expected \"image\" field with a file.' }),\n        { \n          status: 400, \n          headers: { ...corsHeaders, 'Content-Type': 'application/json' } \n        }\n      )\n    }\n\n    if (imageFile.size === 0) {\n      return new Response(\n        JSON.stringify({ error: 'Image file is empty.' }),\n        { \n          status: 400, \n          headers: { ...corsHeaders, 'Content-Type': 'application/json' } \n        }\n      )\n    }\n\n    if (imageFile.size > MAX_IMAGE_BYTES) {\n      return new Response(\n        JSON.stringify({ error: `Image file too large. Maximum size is ${MAX_IMAGE_BYTES / (1024 * 1024)}MB.` }),\n        { \n          status: 400, \n          headers: { ...corsHeaders, 'Content-Type': 'application/json' } \n        }\n      )\n    }\n\n    // Extract and validate prompt\n    const userPrompt = (form.get('prompt') || '').toString().trim()\n    \n    if (!userPrompt || userPrompt.length === 0) {\n      return new Response(\n        JSON.stringify({ error: 'No prompt provided. Prompt is required.' }),\n        { \n          status: 400, \n          headers: { ...corsHeaders, 'Content-Type': 'application/json' } \n        }\n      )\n    }\n    \n    // Build final prompt with hard constraints\n    const HARD_CONSTRAINTS = `Keep the exact original drawing style and pose. Do not redraw the face or body shape. Only add accessories and background elements on top. Maintain black outlines, minimal shading, and the same character proportions.`\n    const FINAL_PROMPT = `${HARD_CONSTRAINTS}\\n\\n${userPrompt}`\n\n    // Try gpt-image-1 first (best quality)\n    const r1 = await callEdits({\n      model: 'gpt-image-1',\n      apiKey,\n      imageFile,\n      prompt: FINAL_PROMPT,\n    })\n\n    if (r1.ok) {\n      // gpt-image-1 succeeded - decode b64_json and return PNG\n      if (!r1.json) {\n        return new Response(\n          JSON.stringify({ error: 'OpenAI request failed (non-JSON response)' }),\n          { \n            status: 500, \n            headers: { ...corsHeaders, 'Content-Type': 'application/json' } \n          }\n        )\n      }\n\n      const b64Json = r1.json.data?.[0]?.b64_json\n      if (!b64Json) {\n        return new Response(\n          JSON.stringify({ error: 'No image data in response (missing b64_json)' }),\n          { \n            status: 500, \n            headers: { ...corsHeaders, 'Content-Type': 'application/json' } \n          }\n        )\n      }\n\n      const bytes = base64ToBytes(b64Json)\n      return new Response(bytes, {\n        status: 200,\n        headers: {\n          ...corsHeaders,\n          'Content-Type': 'image/png',\n          'X-Tangify-Model': 'gpt-image-1',\n          'Cache-Control': 'no-store',\n        },\n      })\n    }\n\n    // Check if verification/permission error (precise matching)\n    if (isVerificationOrPermissionError(r1.json, r1.status)) {\n      // Fallback to dall-e-2\n      const r2 = await callEdits({\n        model: 'dall-e-2',\n        apiKey,\n        imageFile,\n        prompt: FINAL_PROMPT,\n      })\n\n      if (r2.ok) {\n        // dall-e-2 succeeded - decode b64_json and return PNG\n        if (!r2.json) {\n          return new Response(\n            JSON.stringify({ error: 'OpenAI request failed (non-JSON response)' }),\n            { \n              status: 500, \n              headers: { ...corsHeaders, 'Content-Type': 'application/json' } \n            }\n          )\n        }\n\n        const b64Json = r2.json.data?.[0]?.b64_json\n        if (!b64Json) {\n          return new Response(\n            JSON.stringify({ error: 'No image data in response (missing b64_json)' }),\n            { \n              status: 500, \n              headers: { ...corsHeaders, 'Content-Type': 'application/json' } \n            }\n          )\n        }\n\n        const bytes = base64ToBytes(b64Json)\n        return new Response(bytes, {\n          status: 200,\n          headers: {\n            ...corsHeaders,\n            'Content-Type': 'image/png',\n            'X-Tangify-Model': 'dall-e-2',\n            'Cache-Control': 'no-store',\n          },\n        })\n      } else {\n        // dall-e-2 also failed - return error\n        let errorMessage = 'Failed to edit image'\n        if (r2.json?.error?.message) {\n          errorMessage = r2.json.error.message\n        } else if (!r2.json) {\n          errorMessage = 'OpenAI request failed (non-JSON response)'\n        }\n\n        return new Response(\n          JSON.stringify({ error: errorMessage }),\n          { \n            status: r2.status, \n            headers: { ...corsHeaders, 'Content-Type': 'application/json' } \n          }\n        )\n      }\n    } else {\n      // gpt-image-1 failed for other reasons (not verification/permission) - return error\n      let errorMessage = 'Failed to edit image'\n      if (r1.json?.error?.message) {\n        errorMessage = r1.json.error.message\n      } else if (r1.json?.error) {\n        // Handle case where error is directly in json.error (not json.error.message)\n        errorMessage = typeof r1.json.error === 'string' ? r1.json.error : JSON.stringify(r1.json.error)\n      } else if (!r1.json) {\n        errorMessage = 'OpenAI request failed (non-JSON response)'\n      }\n\n      return new Response(\n        JSON.stringify({ error: errorMessage }),\n        { \n          status: r1.status || 500, \n          headers: { ...corsHeaders, 'Content-Type': 'application/json' } \n        }\n      )\n    }\n\n  } catch (error) {\n    console.error('Tangify error:', error)\n    // Provide more detailed error messages\n    let errorMessage = error.message || 'Internal server error'\n    let statusCode = 500\n    \n    // Handle specific error types\n    if (error.message?.includes('timeout') || error.message?.includes('AbortError')) {\n      errorMessage = 'Request timed out. The image generation is taking too long. Please try again with a smaller image or simpler prompt.'\n      statusCode = 504\n    } else if (error.message?.includes('network') || error.message?.includes('fetch') || error.message?.includes('connection')) {\n      errorMessage = `Network connection error: ${error.message}. Please check your internet connection and try again.`\n      statusCode = 503\n    }\n    \n    return new Response(\n      JSON.stringify({ error: errorMessage }),\n      { \n        status: statusCode, \n        headers: { ...corsHeaders, 'Content-Type': 'application/json' } \n      }\n    )\n  }\n}\n\nexport async function onRequestOptions() {\n  return new Response(null, {\n    status: 204,\n    headers: corsHeaders,\n  })\n}\n", "/**\n * Cloudflare Pages Function: Wallet Balances Proxy\n * Proxies requests to Spacescan.io API to avoid CORS issues\n * \n * Endpoint: /api/wallet-balances?address=xch1...\n */\n\nexport async function onRequestGet(context) {\n  const { request, env } = context\n  const url = new URL(request.url)\n  const address = url.searchParams.get('address')\n\n  if (!address) {\n    return new Response(\n      JSON.stringify({ error: 'Missing address parameter' }),\n      {\n        status: 400,\n        headers: {\n          'Content-Type': 'application/json',\n          'Access-Control-Allow-Origin': '*',\n        },\n      }\n    )\n  }\n\n  // Try endpoints in priority order\n  // PRIMARY: XCHScan (most reliable, returns XCH + CATs in one call)\n  // FALLBACK: Spacescan api2 format\n  // LAST RESORT: Spacescan XCH-only endpoint\n  const endpointsToTry = [\n    `https://api.xchscan.com/address/${address}`, // PRIMARY - most reliable\n    `https://api2.spacescan.io/1/xch/address/balance/${address}`, // FALLBACK 1\n    `https://api.spacescan.io/address/xch-balance/${address}`, // FALLBACK 2 - XCH only\n  ]\n\n  const errors = []\n  let lastStatus = null\n\n  // Get API key from environment (Cloudflare Pages secret)\n  const apiKey = env?.spacescan || env?.SPACESCAN_API_KEY || null\n  \n  for (const endpoint of endpointsToTry) {\n    try {\n      // Build headers with API key if available\n      const headers = {\n        'User-Agent': 'WojakInk-Treasury/1.0',\n        'Accept': 'application/json',\n      }\n      \n      // Add API key to headers if available\n      // Spacescan uses Authorization: Bearer format\n      if (apiKey) {\n        headers['Authorization'] = `Bearer ${apiKey}`\n        console.log(`[Wallet Balances Proxy] Using API key for ${endpoint}`)\n      } else {\n        console.log(`[Wallet Balances Proxy] No API key found, using unauthenticated request`)\n      }\n      \n      const response = await fetch(endpoint, {\n        method: 'GET',\n        headers: headers,\n      })\n\n      const status = response.status\n      const responseText = await response.text()\n\n      // Log for debugging (will show in wrangler logs)\n      console.log(`[Wallet Balances Proxy] ${endpoint} - Status: ${status}`)\n\n      if (response.ok) {\n        // Success! Return the response\n        try {\n          const data = JSON.parse(responseText)\n          console.log(`[Wallet Balances Proxy] Success! Response keys:`, Object.keys(data || {}))\n          \n          return new Response(responseText, {\n            status: 200,\n            headers: {\n              'Content-Type': 'application/json',\n              'Access-Control-Allow-Origin': '*',\n              'X-Proxied-Endpoint': endpoint,\n              'Cache-Control': 'public, max-age=240', // 4 min cache\n            },\n          })\n        } catch (parseError) {\n          // JSON parse failed, but status was OK - return the text anyway\n          console.warn(`[Wallet Balances Proxy] JSON parse failed for ${endpoint}:`, parseError)\n          return new Response(responseText, {\n            status: 200,\n            headers: {\n              'Content-Type': 'text/plain',\n              'Access-Control-Allow-Origin': '*',\n              'X-Proxied-Endpoint': endpoint,\n            },\n          })\n        }\n      }\n\n      // Not OK - save error details\n      const errorInfo = {\n        endpoint,\n        status,\n        error: `HTTP ${status}: ${response.statusText}`,\n        responsePreview: responseText.substring(0, 200), // First 200 chars\n      }\n      errors.push(errorInfo)\n      lastStatus = status\n\n      // For 429 (rate limit), continue to next endpoint (don't stop)\n      if (status === 429) {\n        console.log(`[Wallet Balances Proxy] \u23F8\uFE0F Rate limited: ${endpoint}, trying next endpoint...`)\n        // Wait 1 second before trying next endpoint (be nice to APIs)\n        await new Promise(resolve => setTimeout(resolve, 1000))\n        continue // Try next endpoint\n      }\n\n      // For 404, also continue (endpoint might not exist, but others might work)\n      if (status === 404) {\n        console.log(`[Wallet Balances Proxy] \u274C Not found: ${endpoint}, trying next endpoint...`)\n        continue // Try next endpoint\n      }\n\n      // For 500 errors, wait a bit then continue\n      if (status >= 500) {\n        console.log(`[Wallet Balances Proxy] \u274C Server error: ${endpoint} (${status}), trying next endpoint...`)\n        await new Promise(resolve => setTimeout(resolve, 1000))\n        continue // Try next endpoint\n      }\n\n      // Continue to next endpoint for other errors (502, 503, etc.)\n    } catch (error) {\n      console.error(`[Wallet Balances Proxy] Error fetching ${endpoint}:`, error)\n      errors.push({\n        endpoint,\n        status: null,\n        error: error.message,\n        responsePreview: null,\n      })\n      // Continue to next endpoint\n    }\n  }\n\n  // All endpoints failed - return structured error\n  const hasRateLimit = errors.some(e => e.status === 429)\n  const hint = hasRateLimit\n    ? 'Rate limit hit. Wait 5-10 minutes and try again.'\n    : 'API may be down. Check https://spacescan.io status.'\n\n  return new Response(\n    JSON.stringify({\n      success: false,\n      error: 'All API endpoints failed',\n      tried: errors.map(e => ({\n        endpoint: e.endpoint,\n        status: e.status,\n        error: e.error,\n      })),\n      hint,\n      lastStatus,\n    }),\n    {\n      status: lastStatus || 503,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*',\n      },\n    }\n  )\n}\n\n", "import { onRequestGet as __api_offers_js_onRequestGet } from \"/Users/abit_hex/Downloads/wojak-ink-v2/wojak-ink/functions/api/offers.js\"\nimport { onRequestOptions as __api_tangify_js_onRequestOptions } from \"/Users/abit_hex/Downloads/wojak-ink-v2/wojak-ink/functions/api/tangify.js\"\nimport { onRequestPost as __api_tangify_js_onRequestPost } from \"/Users/abit_hex/Downloads/wojak-ink-v2/wojak-ink/functions/api/tangify.js\"\nimport { onRequestGet as __api_wallet_balances_js_onRequestGet } from \"/Users/abit_hex/Downloads/wojak-ink-v2/wojak-ink/functions/api/wallet-balances.js\"\n\nexport const routes = [\n    {\n      routePath: \"/api/offers\",\n      mountPath: \"/api\",\n      method: \"GET\",\n      middlewares: [],\n      modules: [__api_offers_js_onRequestGet],\n    },\n  {\n      routePath: \"/api/tangify\",\n      mountPath: \"/api\",\n      method: \"OPTIONS\",\n      middlewares: [],\n      modules: [__api_tangify_js_onRequestOptions],\n    },\n  {\n      routePath: \"/api/tangify\",\n      mountPath: \"/api\",\n      method: \"POST\",\n      middlewares: [],\n      modules: [__api_tangify_js_onRequestPost],\n    },\n  {\n      routePath: \"/api/wallet-balances\",\n      mountPath: \"/api\",\n      method: \"GET\",\n      middlewares: [],\n      modules: [__api_wallet_balances_js_onRequestGet],\n    },\n  ]", "/**\n * Tokenizer results.\n */\ninterface LexToken {\n  type:\n    | \"OPEN\"\n    | \"CLOSE\"\n    | \"PATTERN\"\n    | \"NAME\"\n    | \"CHAR\"\n    | \"ESCAPED_CHAR\"\n    | \"MODIFIER\"\n    | \"END\";\n  index: number;\n  value: string;\n}\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str: string): LexToken[] {\n  const tokens: LexToken[] = [];\n  let i = 0;\n\n  while (i < str.length) {\n    const char = str[i];\n\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \":\") {\n      let name = \"\";\n      let j = i + 1;\n\n      while (j < str.length) {\n        const code = str.charCodeAt(j);\n\n        if (\n          // `0-9`\n          (code >= 48 && code <= 57) ||\n          // `A-Z`\n          (code >= 65 && code <= 90) ||\n          // `a-z`\n          (code >= 97 && code <= 122) ||\n          // `_`\n          code === 95\n        ) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError(`Missing parameter name at ${i}`);\n\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      i = j;\n      continue;\n    }\n\n    if (char === \"(\") {\n      let count = 1;\n      let pattern = \"\";\n      let j = i + 1;\n\n      if (str[j] === \"?\") {\n        throw new TypeError(`Pattern cannot start with \"?\" at ${j}`);\n      }\n\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(`Capturing groups are not allowed at ${j}`);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError(`Unbalanced pattern at ${i}`);\n      if (!pattern) throw new TypeError(`Missing pattern at ${i}`);\n\n      tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n      i = j;\n      continue;\n    }\n\n    tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n  }\n\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n\n  return tokens;\n}\n\nexport interface ParseOptions {\n  /**\n   * Set the default delimiter for repeat parameters. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters to automatically consider prefixes when parsing.\n   */\n  prefixes?: string;\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): Token[] {\n  const tokens = lexer(str);\n  const { prefixes = \"./\", delimiter = \"/#?\" } = options;\n  const result: Token[] = [];\n  let key = 0;\n  let i = 0;\n  let path = \"\";\n\n  const tryConsume = (type: LexToken[\"type\"]): string | undefined => {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  const mustConsume = (type: LexToken[\"type\"]): string => {\n    const value = tryConsume(type);\n    if (value !== undefined) return value;\n    const { type: nextType, index } = tokens[i];\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n  };\n\n  const consumeText = (): string => {\n    let result = \"\";\n    let value: string | undefined;\n    while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n      result += value;\n    }\n    return result;\n  };\n\n  const isSafe = (value: string): boolean => {\n    for (const char of delimiter) if (value.indexOf(char) > -1) return true;\n    return false;\n  };\n\n  const safePattern = (prefix: string) => {\n    const prev = result[result.length - 1];\n    const prevText = prefix || (prev && typeof prev === \"string\" ? prev : \"\");\n\n    if (prev && !prevText) {\n      throw new TypeError(\n        `Must have text between two parameters, missing text after \"${(prev as Key).name}\"`,\n      );\n    }\n\n    if (!prevText || isSafe(prevText)) return `[^${escapeString(delimiter)}]+?`;\n    return `(?:(?!${escapeString(prevText)})[^${escapeString(delimiter)}])+?`;\n  };\n\n  while (i < tokens.length) {\n    const char = tryConsume(\"CHAR\");\n    const name = tryConsume(\"NAME\");\n    const pattern = tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      let prefix = char || \"\";\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n\n      result.push({\n        name: name || key++,\n        prefix,\n        suffix: \"\",\n        pattern: pattern || safePattern(prefix),\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    const value = char || tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n\n    const open = tryConsume(\"OPEN\");\n    if (open) {\n      const prefix = consumeText();\n      const name = tryConsume(\"NAME\") || \"\";\n      const pattern = tryConsume(\"PATTERN\") || \"\";\n      const suffix = consumeText();\n\n      mustConsume(\"CLOSE\");\n\n      result.push({\n        name: name || (pattern ? key++ : \"\"),\n        pattern: name && !pattern ? safePattern(prefix) : pattern,\n        prefix,\n        suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    mustConsume(\"END\");\n  }\n\n  return result;\n}\n\nexport interface TokensToFunctionOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Function for encoding input strings for output.\n   */\n  encode?: (value: string, token: Key) => string;\n  /**\n   * When `false` the function can produce an invalid (unmatched) path. (default: `true`)\n   */\n  validate?: boolean;\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends object = object>(\n  str: string,\n  options?: ParseOptions & TokensToFunctionOptions,\n) {\n  return tokensToFunction<P>(parse(str, options), options);\n}\n\nexport type PathFunction<P extends object = object> = (data?: P) => string;\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction<P extends object = object>(\n  tokens: Token[],\n  options: TokensToFunctionOptions = {},\n): PathFunction<P> {\n  const reFlags = flags(options);\n  const { encode = (x: string) => x, validate = true } = options;\n\n  // Compile all the tokens into regexps.\n  const matches = tokens.map((token) => {\n    if (typeof token === \"object\") {\n      return new RegExp(`^(?:${token.pattern})$`, reFlags);\n    }\n  });\n\n  return (data: Record<string, any> | null | undefined) => {\n    let path = \"\";\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      const value = data ? data[token.name] : undefined;\n      const optional = token.modifier === \"?\" || token.modifier === \"*\";\n      const repeat = token.modifier === \"*\" || token.modifier === \"+\";\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to not repeat, but got an array`,\n          );\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n\n          throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n        }\n\n        for (let j = 0; j < value.length; j++) {\n          const segment = encode(value[j], token);\n\n          if (validate && !(matches[i] as RegExp).test(segment)) {\n            throw new TypeError(\n              `Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`,\n            );\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        const segment = encode(String(value), token);\n\n        if (validate && !(matches[i] as RegExp).test(segment)) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`,\n          );\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n\n      const typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n    }\n\n    return path;\n  };\n}\n\nexport interface RegexpToFunctionOptions {\n  /**\n   * Function for decoding strings for params.\n   */\n  decode?: (value: string, token: Key) => string;\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends object = object> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends object = object> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends object = object> = (\n  path: string,\n) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends object = object>(\n  str: Path,\n  options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions,\n) {\n  const keys: Key[] = [];\n  const re = pathToRegexp(str, keys, options);\n  return regexpToFunction<P>(re, keys, options);\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction<P extends object = object>(\n  re: RegExp,\n  keys: Key[],\n  options: RegexpToFunctionOptions = {},\n): MatchFunction<P> {\n  const { decode = (x: string) => x } = options;\n\n  return function (pathname: string) {\n    const m = re.exec(pathname);\n    if (!m) return false;\n\n    const { 0: path, index } = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map((value) => {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    }\n\n    return { path, index, params };\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str: string) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options?: { sensitive?: boolean }) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n\n/**\n * Metadata about a key.\n */\nexport interface Key {\n  name: string | number;\n  prefix: string;\n  suffix: string;\n  pattern: string;\n  modifier: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path: RegExp, keys?: Key[]): RegExp {\n  if (!keys) return path;\n\n  const groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n  let index = 0;\n  let execResult = groupsRegex.exec(path.source);\n  while (execResult) {\n    keys.push({\n      // Use parenthesized substring match if available, index otherwise\n      name: execResult[1] || index++,\n      prefix: \"\",\n      suffix: \"\",\n      modifier: \"\",\n      pattern: \"\",\n    });\n    execResult = groupsRegex.exec(path.source);\n  }\n\n  return path;\n}\n\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(\n  paths: Array<string | RegExp>,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions,\n): RegExp {\n  const parts = paths.map((path) => pathToRegexp(path, keys, options).source);\n  return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\n}\n\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(\n  path: string,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions,\n) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n\nexport interface TokensToRegexpOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * When `true` the regexp won't allow an optional trailing delimiter to match. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * When `true` the regexp will match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * When `true` the regexp will match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * Sets the final character for non-ending optimistic matches. (default: `/`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters that can also be \"end\" characters.\n   */\n  endsWith?: string;\n  /**\n   * Encode path tokens for use in the `RegExp`.\n   */\n  encode?: (value: string) => string;\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(\n  tokens: Token[],\n  keys?: Key[],\n  options: TokensToRegexpOptions = {},\n) {\n  const {\n    strict = false,\n    start = true,\n    end = true,\n    encode = (x: string) => x,\n    delimiter = \"/#?\",\n    endsWith = \"\",\n  } = options;\n  const endsWithRe = `[${escapeString(endsWith)}]|$`;\n  const delimiterRe = `[${escapeString(delimiter)}]`;\n  let route = start ? \"^\" : \"\";\n\n  // Iterate over the tokens and create our regexp string.\n  for (const token of tokens) {\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      const prefix = escapeString(encode(token.prefix));\n      const suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            const mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\n          } else {\n            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\n          }\n        } else {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            throw new TypeError(\n              `Can not repeat \"${token.name}\" without a prefix and suffix`,\n            );\n          }\n\n          route += `(${token.pattern})${token.modifier}`;\n        }\n      } else {\n        route += `(?:${prefix}${suffix})${token.modifier}`;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += `${delimiterRe}?`;\n\n    route += !options.endsWith ? \"$\" : `(?=${endsWithRe})`;\n  } else {\n    const endToken = tokens[tokens.length - 1];\n    const isEndDelimited =\n      typeof endToken === \"string\"\n        ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n        : endToken === undefined;\n\n    if (!strict) {\n      route += `(?:${delimiterRe}(?=${endsWithRe}))?`;\n    }\n\n    if (!isEndDelimited) {\n      route += `(?=${delimiterRe}|${endsWithRe})`;\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\n/**\n * Supported `path-to-regexp` input types.\n */\nexport type Path = string | RegExp | Array<string | RegExp>;\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(\n  path: Path,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions,\n) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n", "import { match } from \"path-to-regexp\";\n\n//note: this explicitly does not include the * character, as pages requires this\nconst escapeRegex = /[.+?^${}()|[\\]\\\\]/g;\n\ntype HTTPMethod =\n\t| \"HEAD\"\n\t| \"OPTIONS\"\n\t| \"GET\"\n\t| \"POST\"\n\t| \"PUT\"\n\t| \"PATCH\"\n\t| \"DELETE\";\n\n/* TODO: Grab these from @cloudflare/workers-types instead */\ntype Params<P extends string = string> = Record<P, string | string[]>;\n\ntype EventContext<Env, P extends string, Data> = {\n\trequest: Request;\n\tfunctionPath: string;\n\twaitUntil: (promise: Promise<unknown>) => void;\n\tpassThroughOnException: () => void;\n\tnext: (input?: Request | string, init?: RequestInit) => Promise<Response>;\n\tenv: Env & { ASSETS: { fetch: typeof fetch } };\n\tparams: Params<P>;\n\tdata: Data;\n};\n\ndeclare type PagesFunction<\n\tEnv = unknown,\n\tP extends string = string,\n\tData extends Record<string, unknown> = Record<string, unknown>,\n> = (context: EventContext<Env, P, Data>) => Response | Promise<Response>;\n/* end @cloudflare/workers-types */\n\ntype RouteHandler = {\n\troutePath: string;\n\tmountPath: string;\n\tmethod?: HTTPMethod;\n\tmodules: PagesFunction[];\n\tmiddlewares: PagesFunction[];\n};\n\n// inject `routes` via ESBuild\ndeclare const routes: RouteHandler[];\n// define `__FALLBACK_SERVICE__` via ESBuild\ndeclare const __FALLBACK_SERVICE__: string;\n\n// expect an ASSETS fetcher binding pointing to the asset-server stage\ntype FetchEnv = {\n\t[name: string]: { fetch: typeof fetch };\n\tASSETS: { fetch: typeof fetch };\n};\n\ntype WorkerContext = {\n\twaitUntil: (promise: Promise<unknown>) => void;\n\tpassThroughOnException: () => void;\n};\n\nfunction* executeRequest(request: Request) {\n\tconst requestPath = new URL(request.url).pathname;\n\n\t// First, iterate through the routes (backwards) and execute \"middlewares\" on partial route matches\n\tfor (const route of [...routes].reverse()) {\n\t\tif (route.method && route.method !== request.method) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// replaces with \"\\\\$&\", this prepends a backslash to the matched string, e.g. \"[\" becomes \"\\[\"\n\t\tconst routeMatcher = match(route.routePath.replace(escapeRegex, \"\\\\$&\"), {\n\t\t\tend: false,\n\t\t});\n\t\tconst mountMatcher = match(route.mountPath.replace(escapeRegex, \"\\\\$&\"), {\n\t\t\tend: false,\n\t\t});\n\t\tconst matchResult = routeMatcher(requestPath);\n\t\tconst mountMatchResult = mountMatcher(requestPath);\n\t\tif (matchResult && mountMatchResult) {\n\t\t\tfor (const handler of route.middlewares.flat()) {\n\t\t\t\tyield {\n\t\t\t\t\thandler,\n\t\t\t\t\tparams: matchResult.params as Params,\n\t\t\t\t\tpath: mountMatchResult.path,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\t// Then look for the first exact route match and execute its \"modules\"\n\tfor (const route of routes) {\n\t\tif (route.method && route.method !== request.method) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst routeMatcher = match(route.routePath.replace(escapeRegex, \"\\\\$&\"), {\n\t\t\tend: true,\n\t\t});\n\t\tconst mountMatcher = match(route.mountPath.replace(escapeRegex, \"\\\\$&\"), {\n\t\t\tend: false,\n\t\t});\n\t\tconst matchResult = routeMatcher(requestPath);\n\t\tconst mountMatchResult = mountMatcher(requestPath);\n\t\tif (matchResult && mountMatchResult && route.modules.length) {\n\t\t\tfor (const handler of route.modules.flat()) {\n\t\t\t\tyield {\n\t\t\t\t\thandler,\n\t\t\t\t\tparams: matchResult.params as Params,\n\t\t\t\t\tpath: matchResult.path,\n\t\t\t\t};\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nexport default {\n\tasync fetch(\n\t\toriginalRequest: Request,\n\t\tenv: FetchEnv,\n\t\tworkerContext: WorkerContext\n\t) {\n\t\tlet request = originalRequest;\n\t\tconst handlerIterator = executeRequest(request);\n\t\tlet data = {}; // arbitrary data the user can set between functions\n\t\tlet isFailOpen = false;\n\n\t\tconst next = async (input?: RequestInfo, init?: RequestInit) => {\n\t\t\tif (input !== undefined) {\n\t\t\t\tlet url = input;\n\t\t\t\tif (typeof input === \"string\") {\n\t\t\t\t\turl = new URL(input, request.url).toString();\n\t\t\t\t}\n\t\t\t\trequest = new Request(url, init);\n\t\t\t}\n\n\t\t\tconst result = handlerIterator.next();\n\t\t\t// Note we can't use `!result.done` because this doesn't narrow to the correct type\n\t\t\tif (result.done === false) {\n\t\t\t\tconst { handler, params, path } = result.value;\n\t\t\t\tconst context = {\n\t\t\t\t\trequest: new Request(request.clone()),\n\t\t\t\t\tfunctionPath: path,\n\t\t\t\t\tnext,\n\t\t\t\t\tparams,\n\t\t\t\t\tget data() {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t},\n\t\t\t\t\tset data(value) {\n\t\t\t\t\t\tif (typeof value !== \"object\" || value === null) {\n\t\t\t\t\t\t\tthrow new Error(\"context.data must be an object\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// user has overriden context.data, so we need to merge it with the existing data\n\t\t\t\t\t\tdata = value;\n\t\t\t\t\t},\n\t\t\t\t\tenv,\n\t\t\t\t\twaitUntil: workerContext.waitUntil.bind(workerContext),\n\t\t\t\t\tpassThroughOnException: () => {\n\t\t\t\t\t\tisFailOpen = true;\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tconst response = await handler(context);\n\n\t\t\t\tif (!(response instanceof Response)) {\n\t\t\t\t\tthrow new Error(\"Your Pages function should return a Response\");\n\t\t\t\t}\n\n\t\t\t\treturn cloneResponse(response);\n\t\t\t} else if (__FALLBACK_SERVICE__) {\n\t\t\t\t// There are no more handlers so finish with the fallback service (`env.ASSETS.fetch` in Pages' case)\n\t\t\t\tconst response = await env[__FALLBACK_SERVICE__].fetch(request);\n\t\t\t\treturn cloneResponse(response);\n\t\t\t} else {\n\t\t\t\t// There was not fallback service so actually make the request to the origin.\n\t\t\t\tconst response = await fetch(request);\n\t\t\t\treturn cloneResponse(response);\n\t\t\t}\n\t\t};\n\n\t\ttry {\n\t\t\treturn await next();\n\t\t} catch (error) {\n\t\t\tif (isFailOpen) {\n\t\t\t\tconst response = await env[__FALLBACK_SERVICE__].fetch(request);\n\t\t\t\treturn cloneResponse(response);\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t},\n};\n\n// This makes a Response mutable\nconst cloneResponse = (response: Response) =>\n\t// https://fetch.spec.whatwg.org/#null-body-status\n\tnew Response(\n\t\t[101, 204, 205, 304].includes(response.status) ? null : response.body,\n\t\tresponse\n\t);\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/Users/abit_hex/Downloads/wojak-ink-v2/node_modules/wrangler/templates/pages-template-worker.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/Users/abit_hex/Downloads/wojak-ink-v2/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"/Users/abit_hex/Downloads/wojak-ink-v2/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"/Users/abit_hex/Downloads/wojak-ink-v2/node_modules/wrangler/templates/pages-template-worker.ts\";\n\t\t\t\tconst MIDDLEWARE_TEST_INJECT = \"__INJECT_FOR_TESTING_WRANGLER_MIDDLEWARE__\";\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"/Users/abit_hex/Downloads/wojak-ink-v2/wojak-ink/.wrangler/tmp/bundle-t1QkpV/middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"/Users/abit_hex/Downloads/wojak-ink-v2/node_modules/wrangler/templates/middleware/common.ts\";\nimport type { WorkerEntrypointConstructor } from \"/Users/abit_hex/Downloads/wojak-ink-v2/wojak-ink/.wrangler/tmp/bundle-t1QkpV/middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"/Users/abit_hex/Downloads/wojak-ink-v2/wojak-ink/.wrangler/tmp/bundle-t1QkpV/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": ["data", "reverseMap", "onRequestGet", "onRequestGet", "value", "_a", "result", "char", "prefix", "i"]
}
